# Code hunt 1

## 1. 서론

본 보고서는 “색깔 여행(Colorful Tour)” 문제를 해결하기 위한 알고리즘의 개요와, 문제에서 제시된 두 번째 예제 입력이 실제로는 모순을 포함하고 있음을 설명한다.  
문제 요약은 다음과 같다. 정점에 1부터 K까지 색깔이 주어지고, 방향 그래프가 구성되어 있다. 1부터 K까지 모든 색깔을 적어도 한 번씩 방문하는 경로 중에서 간선 비용 합이 최소인 값을 찾아야 하며, 만약 그런 경로가 전혀 없다면 -1을 출력한다.

문제에서 주어진 두 가지 예제 중, 첫 번째 예제는 알고리즘을 통해 최소 비용이 7로 올바르게 계산되지만, 두 번째 예제는 “-1”이 예시 출력으로 주어져 있음에도 불구하고 실제로는 모든 색깔을 방문하는 경로가 존재한다. 이 보고서는 해당 모순을 논리적으로 밝히고, 왜 -1이 아니라 다른 비용이 나오는지에 대한 이유를 기술한다.

---

## 2. 알고리즘 개요

### 2.1 아이디어

1. **비트마스크**를 통해 색깔 방문 상태를 관리한다. K <= 10이므로 방문한 색깔들을 2^K로 나타낼 수 있다.
2. 상태 `dist[v][mask]`를 “정점 v에 있으면서, 방문 색깔 상태가 mask일 때의 최소 비용”으로 정의한다.
3. **방향 그래프에서의 최단 경로 알고리즘(다익스트라)**를 확장하여, (정점, 색깔비트마스크) 쌍을 노드처럼 다룬다. 정점 v에서 w로 이동할 때, w의 색깔 비트를 추가한 mask로 전이시킨다.
4. 모든 색깔(1부터 K까지)을 방문했는지는 최종적으로 비트마스크가 `(1 << K) - 1`인지로 확인한다. `dist[v][(1 << K) - 1]` 중 최소값이 답이 된다. 경로가 없으면 -1을 출력한다.

### 2.2 복잡도

상태의 개수는 `N * (2^K)`이 된다. `N <= 1000`, `M <= 5000`, `K <= 10` 범위 내에서 다익스트라의 우선순위 큐 사용 시 `O(M log(N 2^K))` 정도이므로 충분히 계산 가능하다.

---

## 3. 예제 2의 모순

문제에서 두 번째 예제로 제시된 입력은 다음과 같은 그래프를 구성한다.

- **정점 색깔**

  - 1번 정점: 색깔 1
  - 2번 정점: 색깔 2
  - 3번 정점: 색깔 3
  - 4번 정점: 색깔 3

- **간선 방향 및 비용**
  - 1 -> 2 (2), 2 -> 3 (2), 2 -> 4 (5), 3 -> 4 (1)

이를 보면, 정점 1에서 2로 이동해 비용 2를 쓰고, 이어서 정점 2에서 3으로 이동해 비용 2를 더하면 총 비용 4로 색깔 1, 2, 3을 모두 방문한다. 따라서 “모든 색깔을 방문할 수 없다”는 상황이 아니다. 문제 설명상 “모든 색깔 방문이 불가능할 때 -1”이라 했으므로, 실제로는 경로가 존재하므로 -1이 될 수 없다. 이 예제가 -1을 출력해 달라고 하는 것은 문제의 조건과 충돌한다.

---

## 4. 결론

1. **비트마스크 + 다익스트라** 방식으로 “모든 색깔을 방문하는 최소 비용 경로”를 구하는 알고리즘은 정상적이다. 첫 번째 예제에서는 최소 비용이 7로 예제 출력과 일치한다.
2. 두 번째 예제 그래프에서는 색깔 1, 2, 3을 방문하는 경로(예: `1 -> 2 -> 3`)가 존재하므로 -1이 될 수 없다. 따라서 주어진 예제 2의 출력이 -1이라는 것은 문제 본문과 불일치하거나 추가 제약이 누락된 것으로 보인다.
3. 결론적으로, 예제 2는 문제에서 제시된 조건만으로는 -1을 만족시키기 어렵다. 해당 예제가 잘못 기재되었거나, 실제로는 특별한 추가 규칙이 있어야만 -1이 될 것이다. 하지만 문제의 원문에 그러한 제약이 적시되지 않았으므로, 현 상태에서는 모순이 존재한다고 판단된다.

끝.

---

# Code hunt 2

## 1. 문제 요약

이 문제는 방향성이 있는 비순환 그래프(DAG)에서, 모든 간선에 비음수 정수 가중치가 주어집니다. 쿼리 (u, v)가 주어질 때마다, 노드 u에서 노드 v로 가는 경로 중에서 간선 가중치 합이 D로 나누어떨어지는 경로가 몇 개인지를 구해야 합니다. 경로 개수는 매우 커질 수 있으므로 10^9+7로 나눈 나머지를 결과로 출력해야 합니다.

입력 제한:

- 노드 수(N) 최대 100000
- 간선 수(M) 최대 200000
- 쿼리 수(Q) 최대 100000
- D 최대 100

## 2. 알고리즘 개요

1. **위상 정렬**

   - 그래프가 DAG이므로, 모든 노드에 대해 진입 차수를 계산한 뒤 진입 차수가 0인 노드부터 차례대로 큐에서 꺼내며 후속 노드의 진입 차수를 감소시키면, 위상 정렬 순서를 얻을 수 있습니다.

2. **하나의 쿼리에 대한 DP 접근**

   - (u, v) 쿼리가 한 번 주어졌다고 가정합니다.
   - dp[x][r]: “u에서 x로 가는 경로 중, 간선 가중치의 합을 D로 나눈 나머지가 r인 경로의 개수”
   - dp[u][0] = 1로 초기화 (u에서 u로 가는 길이가 0인 경로의 합은 0)
   - 위상 정렬된 순서대로 노드 x를 순회하며, 각 r에 대해 dp[x][r]이 0이 아니라면 x에서 나가는 간선 (x->y, 가중치 w)에 대해 dp[y][(r+w) mod D] += dp[x][r]
   - 최종적으로 dp[v][0]이 곧 “u에서 v로 가는 경로 중, 가중치 합이 D로 나누어떨어지는 개수”가 됩니다.

3. **여러 쿼리를 처리할 때**

   - 위 방법을 매 쿼리마다 수행하면 (N+M)×D 연산이 필요하며, Q개의 쿼리가 모두 최대 범위로 주어지면 계산량이 매우 커질 수 있습니다.
   - 만약 문제에 특정 구조(예: 소스 노드가 제한적이거나, 그래프가 계층 구조) 같은 추가 조건이 없다면, 일반적으로는 위 과정을 각 쿼리마다 반복하는 방식이 문제 정의상 가장 직관적이고 정확한 해법입니다. 다만 실질적인 시간 제한을 만족하기 어려울 수 있습니다.

## 3. **결론**

- “DAG에서 (u→v) 경로 중 간선 가중치 합이 D로 나누어떨어지는 모든 경로 개수” 문제에 대한 표준 해법은, 위상 정렬 후 DP 테이블을 전파해 나가는 방식입니다.
- 쿼리가 많고 N, M, Q가 모두 최대 범위라면 파이썬 등에서 시간 초과가 발생할 가능성이 높습니다. 그래도 문제 조건 그대로 모든 쿼리에 대해 정확한 답을 구하려면 이 접근이 가장 기본적이고 확실한 방법입니다.
